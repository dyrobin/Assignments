/**
 * @brief handler functions for messages of our home-brew p2p protocol.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "p2pn.h"
#include "proto.h"


int msg_seq = 0;

/*----------------- A hash implementation -------------------------------*/
#undef get16bits
#define get16bits(d) (*((const uint16_t *) (d)))

static uint32_t
SuperFastHash (const char * data, int len) {
    uint32_t hash = len, tmp;
    int rem;

    if (len <= 0 || data == NULL) return 0;

    rem = len & 3;
    len >>= 2;

    /* Main loop */
    for (;len > 0; len--) {
        hash  += get16bits (data);
        tmp    = (get16bits (data+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        data  += 2*sizeof (uint16_t);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
        case 3: hash += get16bits (data);
                hash ^= hash << 16;
                hash ^= data[sizeof (uint16_t)] << 18;
                hash += hash >> 11;
                break;
        case 2: hash += get16bits (data);
                hash ^= hash << 11;
                hash += hash >> 17;
                break;
        case 1: hash += *data;
                hash ^= hash << 10;
                hash += hash >> 1;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}
/*---------------- END of the hash implementation -----------------------*/

/**
 * Initialize the protocol header.
 *
 * @param ph      the p2p protocol header.
 * @param msgType the type of the message.
 */
static void
init_p2ph(struct P2P_h* ph, uint8_t msgType)
{
    memset(ph, 0, sizeof(struct P2P_h));

    ph->version = 1;
    ph->ttl = 5;
    ph->msg_type = msgType;
    ph->length = 0;
    ph->reserved = 0;
}

/**
 * Generate a message ID for new messages.
 *
 * The ID is generated by combining a prefix, current time stamp and the
 * message sequence together, and then hash the combination.
 *
 * @param prefix the prefix for hashing.
 */
static uint32_t
gen_msgid(char *prefix)
{
    char buf[512];
    struct timeval now;
    int n;

    if (msg_seq == 0) { /* initial the sequence number */
        srand(time(NULL));
        msg_seq = rand() % 0xFFFF;
    }

    gettimeofday(&now, NULL);

    n = sprintf(buf, "%s#%ld#%ld#%u",
		prefix, now.tv_sec, now.tv_usec, ++msg_seq);

    return SuperFastHash(buf, n);
}

static uint32_t
gen_msgid_wrap()
{
    char buf[SLEN];

    sprintf(buf, "%08X:%04X",
            ltn_addr.sin_addr.s_addr,
            ntohs(ltn_addr.sin_port));
    return gen_msgid(buf);
}

static void
send_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;
    char buf[128];
    unsigned int nbody;
    struct sockaddr_in outgoing_addr;
    socklen_t addrlen;


    ph = (struct P2P_h *) msg;

    /* Filling IP and PORT in header if necessary */

    if (ph->org_ip == 0) {
      /* Set org_ip and port */
      addrlen = sizeof(struct sockaddr_in);
      if (GetSockName(connfd, (struct sockaddr *)&outgoing_addr, &addrlen) == 0) {
        ph->org_ip = outgoing_addr.sin_addr.s_addr;
      } else {
        ph->org_ip = ltn_addr.sin_addr.s_addr;
      }
      ph->org_port = ltn_addr.sin_port;
    }

    /* Filling the message id in header if necessary */
    if (ph->msg_id == 0) {
        sprintf(buf, "%08X:%04X",
                ph->org_ip, ntohs(ph->org_port));
        ph->msg_id = gen_msgid(buf);
    }

    /* filling the length field in header */
    nbody = len - HLEN;
    ph->length = htons(nbody);

    Write(connfd, msg, len);


    p2plog(DEBUG, "out msg TYPE=0x%02X TTL=%d ID:0x%08x LEN=%d/%d\n",
	   ph->msg_type,
	   ph->ttl,
           ph->msg_id,
	   ntohs(ph->length),
	   len);
}

int
forward_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;

    ph = (struct P2P_h *) msg;
    if (ph->ttl < 1) {
        p2plog(ERROR, "Forward message with TTL < 1\n");
        return -1;
    }
    send_p2p_message(connfd, msg, len);

    return 0;
}

uint32_t send_join_message(int connfd)
{
    struct P2P_h ph;
    init_p2ph(&ph, MSG_JOIN);

    send_p2p_message(connfd, &ph, sizeof(ph));
    return ph.msg_id;
}

void
send_ping_message(int connfd, int ttl)
{
    struct P2P_h ph;
    init_p2ph(&ph, MSG_PING);

    ph.ttl = ttl;
    send_p2p_message(connfd, &ph, sizeof(ph));
}

void handle_ping_message(int connfd, const void *msg, unsigned int len)
{
    struct P2P_h *ph_in, *ph_out;
    struct P2P_pong_front *pf;
    struct P2P_pong_entry *pe;
    struct node_meta *nm;
    char buf[128];
    int count, pong_len;

    ph_in = (struct P2P_h *)msg;

    memset(buf, 0, 128);
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_PONG);
    ph_out->ttl = 1;
    ph_out->msg_id = ph_in->msg_id;

    p2plog(DEBUG, "TTL=%d\n", ph_in->ttl);
    if (ph_in->ttl == 1 && len == HLEN) { /* heartbeat */
        send_p2p_message(connfd, buf, HLEN);
    } else if (ph_in->ttl > 1) { /* network probe */
    /* We use PONG to respond network detection,
       TODO carefully choose return entries can
       avoid very heavy node (which is a node with a lot of peers).
    */
        count = 0;

        list_for_each_entry(nm, &neighbors.list, list) {
            pe = (struct P2P_pong_entry *)
                    (buf + HLEN + PONG_MINLEN + count * PONG_ENTRYLEN);
            if (nm->connfd != connfd) {
                pe->ip = nm->ip;
                pe->port = nm->lport;
                pe->sbz = 0;
                count++;
            }
            if (count >= n_peer_ad)
                break;
        }
        pf = (struct P2P_pong_front *) (buf + HLEN);
        pf->entry_size = htons(count);
        pf->sbz = 0;

        pong_len = HLEN + PONG_MINLEN + count * PONG_ENTRYLEN;
        send_p2p_message(connfd, buf, pong_len);
    }

}

void
handle_pong_message(void *msg, unsigned int len)
{
    struct P2P_pong_front *pf;
    struct P2P_pong_entry *pe;
    struct wtnode_meta *new_wt;
    int i, entry_size;
    char buf[128];

    if (len == HLEN) {
    /* This is a pong message reacting to a previous ping */
    return;
    }
    if (len > HLEN && len < HLEN + PONG_MINLEN) {
    /* Check the length of pong message */
        p2plog(ERROR, "message length (%d) less than mininum\n",
	       len);
        return;
    }

    pf = (struct P2P_pong_front *) ((char *)msg + HLEN);
    entry_size = ntohs(pf->entry_size);
    if (len != entry_size*PONG_ENTRYLEN + PONG_MINLEN + HLEN) {
    /* check if pong's entry size is valid */
        p2plog(ERROR, "invalid length (%d) with entry size = %d\n",
	       len, entry_size);
        return;
    }

    /* iterate each pong entry and add it to waiting list */
    pe = (struct P2P_pong_entry *)((char *)msg + HLEN + PONG_MINLEN);
    p2plog(DEBUG, "PONG with %d entries.\n", entry_size);
    if (suppress_auto_join) {
      p2plog(DEBUG, "Auto join suppressed\n");
      return;
    }
    for (i = 0; i < entry_size; i++) {
        p2plog(DEBUG, "HLEN: %d\n"
               "PONG_MINLEN %d\n"
               "PONG_ENTRYLEN * i %d\n",
               HLEN, PONG_MINLEN, PONG_ENTRYLEN * i);
        pe = (struct P2P_pong_entry *)
                ((char *)msg + HLEN + PONG_MINLEN + PONG_ENTRYLEN * i);

        if (!wtn_contains(&pe->ip, pe->port)
	    && !nm_contains(&pe->ip, pe->port)) {
            new_wt = (struct wtnode_meta *)
                        Malloc(sizeof(struct wtnode_meta));
            wtn_init(new_wt);
            new_wt->ip = pe->ip;
            new_wt->lport = pe->port;
            wt_list_add(new_wt);
            p2plog(DEBUG, "ENTRY: %s: %d, inserted\n",
		   inet_ntop(AF_INET, &pe->ip, buf, 128),
		   ntohs(pe->port));
        } else {
            p2plog(DEBUG, "ENTRY: %s: %d, dupplicate entry, discarded\n",
		   inet_ntop(AF_INET, &pe->ip, buf, 128),
		   ntohs(pe->port));
        }
    }
}


void
handle_join_message(int connfd, const void *msg, unsigned int len)
{
    struct P2P_h *ph_in, *ph_out;
    struct P2P_join *pj;
    struct wtnode_meta *wtn;
    struct node_meta *nm;
    char buf[128];

    ph_in = (struct P2P_h *) msg;
    memset(buf, 0, 128);
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_JOIN);
    ph_out->ttl = 1;
    ph_out->msg_id = ph_in->msg_id;

    p2plog(DEBUG, "Message len = %d, body len = %d\n",
	   len, ntohs(ph_in->length));

    if (len == HLEN) { /* JOIN REQUEST */
        /* send JOIN accept */
        /* Now we just accept any request */
        pj = (struct P2P_join *) (buf + HLEN);
        pj->status = htons(JOIN_ACC);

        /*start to check local database for peer information */
        wtn = wtn_find_by_connfd(connfd);
        if (wtn == NULL) {
        /* JOIN message is not from a waiting node.
           This is not allowed, so we drop this message */
            p2plog(ERROR, "JOIN from an unknown node, connfd = %d\n", connfd);
            return;
        }

        /* This is a self-loop */
        if (wtn_find_by_joinid(ph_in->msg_id) != NULL) {
            p2plog(WARN, "JOIN from ourself - loop detected.\n");
            return;
        }

        nm = nm_find_by_connfd(connfd);
        if (nm == NULL) {
        /* The normal case, JOIN message is from a waiting node,
           and no record for this node is in our neighbors list.
           We should remove record form waiting list and add
           it to neighbor list. Finally, send the JOIN accept msg.*/

            /* this is the first time a peer send us a P2P_h header!
               we should save the identifier of the peer: its ip and
               listening port */
            wtn->lport = ph_in->org_port;
            nm = (struct node_meta*) Malloc(sizeof(struct node_meta));
            nm_init(nm);
            nm->connfd = wtn->connfd;
            nm->ip = wtn->ip;
            nm->lport = wtn->lport;
            nm_list_add(nm);
            wt_list_del(wtn);
            p2plog(INFO, "NEW NEIGHBOR: Accept a new neighbor, %s\n",
		   sock_ntop2(&nm->ip, nm->lport));
        } else {
        /* JOIN request message from a neighbor node.
           Perhaps there are something wrong with my
           JOIN accept message, or the neighbor wants
           to reassure the connection, so we resend the
           accept message */
        }
        /* common action: send JOIN_ACC */
        send_p2p_message(connfd, buf, HLEN + JOINLEN);

    } else if (len == HLEN + JOINLEN
                && ntohs(ph_in->length) == JOINLEN) { /* JOIN RESPONSE */
        pj = (struct P2P_join *) ((char *)msg + HLEN);
        p2plog(DEBUG, "join response: 0x%04X\n", ntohs(pj->status));
        if (ntohs(pj->status) != JOIN_ACC) {
            p2plog(ERROR, "JOIN Refused\n");
            return;
        }
        /* we are accepted by the remote peer
           therefore we should remove the record in the
           waiting list and put it into our neighbor database. */
        wtn = wtn_find_by_connfd(connfd);
        if (wtn == NULL) {
            p2plog(ERROR, "JOIN request accepted by a non-wtn node, connfd=%d\n",
		   connfd);
            return;
        }
        nm = nm_find_by_connfd(connfd);
        if (nm == NULL) {
            nm = (struct node_meta*) Malloc(sizeof(struct node_meta));
            nm_init(nm);
            nm->connfd = wtn->connfd;
            nm->ip = wtn->ip;
            nm->lport = wtn->lport;
            nm_list_add(nm);
            wt_list_del(wtn);
            p2plog(INFO, "NEW NEIGHBOR: JOIN request is accepted by %s\n",
		   sock_ntop2(&nm->ip, nm->lport));
        }
    }
}

uint32_t
search_localdata(struct P2P_h *ph, unsigned int msglen)
{
    char buf[MLEN];
    unsigned int kylen;
    struct keyval *kv;
    kylen = msglen - HLEN;
    if (kylen > KEYLEN) {
        return 0;
    }

    memcpy(buf, ((char*)ph) + HLEN, kylen);
    buf[kylen] = '\0';

    list_for_each_entry(kv, &localdata.list, list) {
	p2plog(DEBUG, "buf = %s, key = %s, cmp = %d\n",
	       buf, kv->key, strcmp(kv->key, buf));
        if (strcmp(kv->key, buf) == 0)
            return kv->value;
    }
    return 0;
}

int
send_query_hit(int connfd, void *msg, uint32_t val)
{
    struct P2P_h *pho, *phme;
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;
    unsigned char buf[MLEN];
    int sendlen;

    pho = (struct P2P_h *) msg;
    phme = (struct P2P_h *) buf;

    init_p2ph(phme, MSG_QHIT);
    phme->msg_id = pho->msg_id;

    qf = (struct P2P_qhit_front *) (buf + HLEN);
    memset(qf, 0, QHIT_MINLEN);
    qf->entry_size = htons(1);

    qe = (struct P2P_qhit_entry *) (buf + HLEN + QHIT_MINLEN);
    memset(qe, 0, QHIT_ENTRYLEN);
    qe->res_id = htons(1);
    qe->res_val = htonl(val);

    sendlen = HLEN + QHIT_MINLEN + QHIT_ENTRYLEN;
    send_p2p_message(connfd, buf, sendlen);
    return 0;
}

int
flood_msg(int fromfd, void *msg, unsigned int msglen)
{
    struct node_meta *nm;

    list_for_each_entry(nm, &neighbors.list, list) {
        if (nm->connfd != fromfd) {
            forward_p2p_message(nm->connfd, msg, msglen);
        }
    }
    return 0;
}

int
handle_query_hit(void *msg, unsigned int msglen)
{
    struct msgstore *ms;
    struct P2P_h *ph;
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;
    struct node_meta *nm;
    char buf[MLEN];
    unsigned int bodylen, i;
    uint16_t nEntry;

    ph = (struct P2P_h *) msg;
    bodylen = ntohs(ph->length);

    if (bodylen < QHIT_MINLEN) {
        p2plog(ERROR, "Message body too small\n");
        return -1;
    }
    qf = (struct P2P_qhit_front *) ((char *)msg + HLEN);

    nEntry = ntohs(qf->entry_size);
    if ((nEntry * QHIT_ENTRYLEN + QHIT_MINLEN + HLEN) != msglen) {
        p2plog(ERROR, "Invalid entry size for QUERY_HIT: %d\n", nEntry);
        return -1;
    }

    if ( (ms = find_stored_msg(&g_recvmsgs, ph->msg_id)) != NULL) {
        if (ms->fromfd == 0) {
            memcpy(buf, (char *)ms->msg + HLEN, ms->len - HLEN);
            buf[ms->len - HLEN] = '\0';
            p2plog(INFO, "query: %s hit, at %s:%d\n",
		   buf,
		   inet_ntop(AF_INET, &ph->org_ip, buf, MLEN),
		   ntohs(ph->org_port));

            for (i = 0; i < nEntry; i++) {
                qe = (struct P2P_qhit_entry *)
                        ((char *)msg + HLEN + QHIT_MINLEN + QHIT_ENTRYLEN * i);
                p2plog(INFO, "resource ID: %08x = %08X\n",
		       ntohs(qe->res_id),
		       ntohl(qe->res_val));
            }
        } else {
            if((nm = nm_find_by_connfd(ms->fromfd)) != NULL){
                /* This QHIT is for a previously forwarded QUERY. */
                ph->ttl = 1;
                /* Relay it back. */
                forward_p2p_message(nm->connfd, msg, msglen);
            } else {
                p2plog(INFO, "no matched peer\n");
                return -1;
            }
        }
    } else {
        p2plog(INFO, "no matched message\n");
        return -1;
    }

    return 0;
}

int send_query_message(char *search)
{
    unsigned char buf[MLEN];
    struct P2P_h *ph;
    struct node_meta *nm;
    int slen, msglen;

    if((slen = strlen(search)) > 64) {
        p2plog(ERROR, "Search key too long\n");
        return 1;
    }
    ph = (struct P2P_h *) buf;
    init_p2ph(ph, MSG_QUERY);
    ph->msg_id = gen_msgid_wrap();

    memcpy(buf + HLEN, search, slen);
    buf[HLEN + slen] = '\0';

    ph->length = htons(slen+1);
    msglen = HLEN + slen + 1;
    push_g_recv_msg(0, ph, msglen);
    list_for_each_entry(nm, &neighbors.list, list) {
        send_p2p_message(nm->connfd, ph, msglen);
    }
    return 0;
}


void
handle_bye_message(int connfd)
{
    struct node_meta *nm;

    if ((nm = nm_find_by_connfd(connfd)) == NULL) {
        p2plog(ERROR, "BYE msg cannot match a neighbor fd\n");
        return;
    }

    close(nm->connfd);
    nm_list_del(nm);
}

