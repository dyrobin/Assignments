/**
 * @brief handler functions for messages of our home-brew p2p protocol.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> 
#include <time.h>
#include <ifaddrs.h>
#include <arpa/inet.h>

#include "list.h"
#include "sock_util.h"
#include "util.h"
#include "proto.h"

extern struct nb_node       g_nb_list;      /* List of neighbour nodes */

extern struct sockaddr_in   g_lstn_addr;    /* Listening address */
extern int                  g_auto_join;    /* Flag of auto join nodes */
extern int                  g_ad_num;       /* Peers number in advertisement */
extern struct ifaddrs      *g_ifaddrs;      /* List of all interfaces */



/*----------------- A hash implementation -------------------------------*/
#undef get16bits
#define get16bits(d) (*((const uint16_t *) (d)))

static uint32_t
SuperFastHash (const char * data, int len) {
    uint32_t hash = len, tmp;
    int rem;

    if (len <= 0 || data == NULL) return 0;

    rem = len & 3;
    len >>= 2;

    /* Main loop */
    for (;len > 0; len--) {
        hash  += get16bits (data);
        tmp    = (get16bits (data+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        data  += 2*sizeof (uint16_t);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
        case 3: hash += get16bits (data);
                hash ^= hash << 16;
                hash ^= data[sizeof (uint16_t)] << 18;
                hash += hash >> 11;
                break;
        case 2: hash += get16bits (data);
                hash ^= hash << 11;
                hash += hash >> 17;
                break;
        case 1: hash += *data;
                hash ^= hash << 10;
                hash += hash >> 1;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}
/*---------------- END of the hash implementation -----------------------*/

/**
 * Generate a message ID for new messages.
 *
 * The ID is generated by combining a prefix, current time stamp and the
 * message sequence together, and then hash the combination.
 *
 * @param prefix the prefix for hashing.
 */
static uint32_t
gen_msgid(char *prefix)
{
    static int msg_seq = 0;
    if (msg_seq == 0) { /* initial the sequence number */        
        msg_seq = rand() % 0xFFFF;
    }

    struct timeval now;
    gettimeofday(&now, NULL);

    int n;
    char buf[S_LEN];
    n = sprintf(buf, "%s#%ld#%ld#%u",
        prefix, now.tv_sec, now.tv_usec, ++msg_seq);

    if (n > S_LEN) {
        p2plog(ERROR, "Buffer out of boundary\n");
        return 0;
    }

    return SuperFastHash(buf, n);
}

static uint32_t
gen_msgid_wrap(uint32_t ipaddr, uint16_t port)
{
    int n;
    char buf[XS_LEN];
    n = sprintf(buf, "%08X:%04X", ipaddr, port);

    if (n > XS_LEN) {
        p2plog(ERROR, "Buffer out of boundary\n");
        return 0;
    }

    return gen_msgid(buf);
}


static uint32_t
is_myself(struct in_addr *addr, uint16_t port)
{
    if (port != g_lstn_addr.sin_port)
        return 0;

    struct ifaddrs *ifa;
    for (ifa = g_ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == NULL)
            continue;

        if (ifa->ifa_addr->sa_family == AF_INET) {
            struct in_addr *tmp;
            tmp = &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
            if (memcmp(addr, tmp, sizeof(struct in_addr)) == 0)
                return 1;
        }
   }

   return 0;
}


/**
 * Initialize the protocol header.
 *
 * @param ph      the p2p protocol header.
 * @param msgType the type of the message.
 */
static void
init_p2ph(struct P2P_h* ph, uint8_t msgType)
{
    memset(ph, 0, sizeof(struct P2P_h));

    ph->version = 1;
    ph->ttl = 5;
    ph->msg_type = msgType;
    ph->length = 0;
    ph->reserved = 0;
}

static int
send_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct nb_node *nb;
    struct wt_node *wt;

    nb = g_nb_list_find_by_connfd(connfd);
    wt = g_wt_list_find_by_connfd(connfd);
    if (nb != NULL && wt == NULL) {
        p2plog(DEBUG, "To neighbor node %s\n", 
            sock_ntop(&nb->ip, nb->lport));
    } else if (nb == NULL && wt != NULL) {
        p2plog(DEBUG, "To waiting node %s\n", 
            sock_ntop(&wt->ip, wt->lport));
    } else if (nb == NULL && wt == NULL) {
        p2plog(ERROR, "No destination found in lists\n");
        return -1;
    } else {
        p2plog(ERROR, "Destination found in both lists\n");
        return -1;
    }

    struct P2P_h *ph;
    ph = (struct P2P_h *) msg;

    /* Filling IP and PORT in header if necessary */
    if (ph->org_ip == 0) {
        struct sockaddr_in outgoing_addr;
        socklen_t addrlen = sizeof(struct sockaddr_in);
        if (GetSockName(connfd, (struct sockaddr *)&outgoing_addr, 
                        &addrlen) == 0) {
            ph->org_ip = outgoing_addr.sin_addr.s_addr;
        } else {
            if (g_lstn_addr.sin_addr.s_addr != INADDR_ANY)
                ph->org_ip = g_lstn_addr.sin_addr.s_addr;
            else {
                p2plog(ERROR, "Orginal IP set failed\n");
                return -1;
            }
        }
        ph->org_port = g_lstn_addr.sin_port;
    }

    /* Filling the message id in header if necessary */
    if (ph->msg_id == 0) {
        uint32_t msg_id;
        msg_id = gen_msgid_wrap(ph->org_ip, ph->org_port);
        if (msg_id == 0) {
            p2plog(ERROR, "Message ID set failed\n");
            return -1;
        }
        ph->msg_id = msg_id;
    }

    /* filling the length field in header */
    if (len < HLEN) {
        p2plog(ERROR, "Message too short\n");
        return -1;
    }
    ph->length = htons(len - HLEN);

    /* sendint to the remote destination */
    int nbytes, nsent = 0, nleft = len;

    while (nleft) {
        if ((nbytes = Write(connfd, (char*)msg + nsent, nleft)) < 0) {
        /* TODO: Check errno == EINTR */
            p2plog(ERROR, "Write error, close fd = %d\n", connfd);
            Close(connfd);
            g_pc_list_remove_by_connfd(connfd);
            if (nb) g_nb_list_del(nb);
            if (wt) g_wt_list_del(wt);
            p2plog(ERROR, "PASS\n");
            return -1;
        }
        nsent += nbytes;
        nleft -= nbytes;
    }

    p2plog(DEBUG, "Out MSG: [%08X], msg_type = %02X, len = %d, ttl = %d\n",
            ph->msg_id, ph->msg_type, ntohs(ph->length), ph->ttl);
    return 0;
}

static int
forward_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;

    ph = (struct P2P_h *) msg;
    if (ph->ttl == 0) {
        p2plog(DEBUG, "Drop message with TTL = 0\n");
        return 0;
    } else {
        return send_p2p_message(connfd, msg, len);
    }
}

static void
flood_msg(int fromfd, void *msg, unsigned int len)
{
    struct nb_node *nb;

    list_for_each_entry(nb, &g_nb_list.list, list) {
        if (nb->connfd != fromfd) {
            forward_p2p_message(nb->connfd, msg, len);
        }
    }
}

/*------------------------------------------------------------------------*/

int 
send_join_message(int connfd)
{
    struct P2P_h ph_out;

    init_p2ph(&ph_out, MSG_JOIN);

    return send_p2p_message(connfd, &ph_out, HLEN);
}

int
handle_join_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph_in;
    struct P2P_join *pj;
    struct in_addr *ipaddr;
    uint16_t lport;

    struct wt_node *wt_in;
    struct nb_node *nb;

    ph_in = (struct P2P_h *) msg;
    ipaddr = (struct in_addr *)&ph_in->org_ip;
    lport = ph_in->org_port;

    if (len == HLEN) { /* JOIN REQUEST */
        /* JOIN message is sent normally after a node connects another one
         * successfully. However, we also allow an established neighbor to 
         * send JOIN in case the response is somehow lost. */
        nb = g_nb_list_find_by_connfd(connfd);
        if (nb == NULL) {
            /* The normal case, JOIN message is from incoming list (merged 
             * with waiting list here) */
            wt_in = g_wt_list_find_by_connfd(connfd);
            if (wt_in == NULL) {
                /* JOIN message is neither from neighbor list nor incoming list
                 * This is not allowed, so we drop this message */
                p2plog(ERROR, "JOIN from an unknown node, connfd = %d\n", 
                       connfd);
                Close(connfd);
                g_pc_list_remove_by_connfd(connfd);
                return -1;
            }

            /* Check if neighbour list contains the duplicated peer that has
             * been already a neighbour. This is the case where an established 
             * neightbour wants to send JOIN using a different socket. */
            struct nb_node *nb_dup = g_nb_list_find_by_peer(ipaddr, lport);
            /* Check if waiting list (excluding incoming list) contains the 
             * duplicated peer that has already sent JOIN request. The peer 
             * might be inserted by PONG message handler. */
            struct wt_node *wt_dup = g_wt_list_find_by_peer(ipaddr, lport);

            if (nb_dup == NULL && wt_dup == NULL) {
                /* This is a new neighbor, insert it into neighbor list */
                g_nb_list_add(nb_new(connfd, ipaddr, lport));
                g_wt_list_del(wt_in);
                p2plog(INFO, "NEW NEIGHBOR: Accept from %s\n",
                       sock_ntop(ipaddr, lport));                
            } else if (nb_dup == NULL && 
                       !wt_requested(wt_dup) && !wt_connected(wt_dup)) {
                /* The peer has been inserted by PONG handler but we haven't 
                 * sent JOIN request yet, we can also accept the peer. */
                g_nb_list_add(nb_new(connfd, ipaddr, lport));
                g_wt_list_del(wt_in);
                /* We can't delete two entries at the same time. Therefore, 
                 * mark it zombie to be deleted later. */
                wt_dup->ts = 0;
                p2plog(INFO, "NEW NEIGHBOR: Accept from %s\n",
                       sock_ntop(ipaddr, lport));
            } else {
                /* Either the neighbourhood has been establised or JOIN request 
                 * has already been sent. Thus, ignore incoming JOIN request
                 * and close connection. */
                p2plog(INFO, "Drop JOIN request coming from %s\n", 
                       sock_ntop(ipaddr, lport));
                Close(connfd);
                g_pc_list_remove_by_connfd(connfd);
                g_wt_list_del(wt_in);
                return -1;
            }
        }
        /* prepare for outgoing JOIN_ACC message */
        char buf[S_LEN];
        struct P2P_h *ph_out;
    
        ph_out = (struct P2P_h *) buf;
        init_p2ph(ph_out, MSG_JOIN);
        ph_out->ttl = 1;
        ph_out->msg_id = ph_in->msg_id;
        pj = (struct P2P_join *) (buf + HLEN);
        pj->status = htons(JOIN_ACC);

        send_p2p_message(connfd, ph_out, HLEN + JOINLEN);
    } else if (len == HLEN + JOINLEN && 
               ntohs(ph_in->length) == JOINLEN) { /* JOIN RESPONSE */
        wt_in = g_wt_list_find_by_connfd(connfd);
        if (wt_in == NULL) {
            p2plog(ERROR, 
                "JOIN request accepted by a non-wtn node, connfd=%d\n", connfd);
            Close(connfd);
            g_pc_list_remove_by_connfd(connfd);
            return -1;
        }

        pj = (struct P2P_join *) ((char *)msg + HLEN);
        p2plog(DEBUG, "JOIN response: 0x%04X\n", ntohs(pj->status));
        if (ntohs(pj->status) != JOIN_ACC) {
            p2plog(ERROR, "JOIN Refused\n");
            Close(connfd);
            g_pc_list_remove_by_connfd(connfd);
            g_wt_list_del(wt_in);
            return -1;
        }

        /* We are accepted by the remote peer, therefore we should remove 
         * the record in the waiting list and put it into our neighbor list. */
        nb = g_nb_list_find_by_connfd(connfd);
        if (nb == NULL) {
            nb = nb_new(connfd, ipaddr, lport);
            g_nb_list_add(nb);
            g_wt_list_del(wt_in);
            p2plog(INFO, "NEW NEIGHBOR: Accepted by %s\n",
                   sock_ntop(&nb->ip, nb->lport));
        }
    }

    return 0;
}

int
send_ping_message(int connfd, int ttl)
{
    struct P2P_h ph_out;

    init_p2ph(&ph_out, MSG_PING);
    ph_out.ttl = ttl;
    
    return send_p2p_message(connfd, &ph_out, HLEN);
}

int
handle_ping_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph_in, *ph_out;
    char buf[M_LEN];

    ph_in = (struct P2P_h *)msg;
    memset(buf, 0, M_LEN);
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_PONG);
    ph_out->ttl = 1;
    ph_out->msg_id = ph_in->msg_id;

    if (ph_in->ttl == 1 && len == HLEN) {
        /* heartbeat */
        p2plog(DEBUG, "Heartbeat\n");
        return send_p2p_message(connfd, ph_out, HLEN);
    }

    /* network probe */
    p2plog(DEBUG, "Probe\n");
    struct P2P_pong_front *pf;
    struct P2P_pong_entry *pe;

    /* Fill in pong entry */
    struct nb_node *nb;
    int count = 0;

    list_for_each_entry(nb, &g_nb_list.list, list) {
        pe = (struct P2P_pong_entry *)
                (buf + HLEN + PONG_MINLEN + count * PONG_ENTRYLEN);
        if (nb->connfd != connfd) {
            pe->ip = nb->ip;
            pe->port = nb->lport;
            pe->sbz = 0;
            count++;
        }
        if (count >= g_ad_num) break;
    }
    /* Fill in pong front */
    pf = (struct P2P_pong_front *) (buf + HLEN);
    pf->entry_size = htons(count);
    pf->sbz = 0;

    return send_p2p_message(connfd, ph_out, 
                            HLEN + PONG_MINLEN + count * PONG_ENTRYLEN);

}

/* TODO: send_pong_message() */

int
handle_pong_message(int connfd, void *msg, unsigned int len)
{
    if (len == HLEN) {
        /* This is a pong message reacting to heartbeat */
        struct nb_node * nb = g_nb_list_find_by_connfd(connfd);
        nb->ts = time(NULL);
        return 0;
    }

    if (len > HLEN && len < HLEN + PONG_MINLEN) {
        /* Check the length of pong message */
        p2plog(ERROR, "PONG length (%d) less than mininum\n", len);
        return -1;
    }

    struct P2P_pong_front *pf;
    int entry_size;

    pf = (struct P2P_pong_front *) ((char *)msg + HLEN);
    entry_size = ntohs(pf->entry_size);
    if (len != entry_size*PONG_ENTRYLEN + PONG_MINLEN + HLEN) {
        /* check if pong's entry size is valid */
        p2plog(ERROR, "PONG invalid length (%d) with entry size = %d\n", 
               len, entry_size);
        return -1;
    }

    struct P2P_pong_entry *pe;
    /* iterate each pong entry and add it to waiting list */
    pe = (struct P2P_pong_entry *)((char *)msg + HLEN + PONG_MINLEN);
    p2plog(DEBUG, "PONG with %d entries.\n", entry_size);
    if (g_auto_join) {
        p2plog(DEBUG, "Auto join suppressed\n");
        return 0;
    }

    int i;
    for (i = 0; i < entry_size; i++) {
        p2plog(DEBUG, "HLEN %d MINLEN %d ENTRYLEN %d\n",
               HLEN, PONG_MINLEN, PONG_ENTRYLEN * i);
        pe = (struct P2P_pong_entry *)
                ((char *)msg + HLEN + PONG_MINLEN + PONG_ENTRYLEN * i);

        /* If the entry contains a self address, ignore it. */
        if (is_myself(&pe->ip, pe->port)) {
            p2plog(WARN, "Self loop detected: %s\n", 
                   sock_ntop(&pe->ip, pe->port));
            continue;
        }

        if (g_wt_list_find_by_peer(&pe->ip, pe->port) == NULL && 
            g_nb_list_find_by_peer(&pe->ip, pe->port) == NULL) {
            g_wt_list_add(wt_new(0, &pe->ip, pe->port));
            p2plog(DEBUG, "ENTRY: %s, inserted\n",
                   sock_ntop(&pe->ip, pe->port));
        } else {
            p2plog(DEBUG, "ENTRY: %s, discarded\n",
                   sock_ntop(&pe->ip, pe->port));
        }
    }

    return 0;
}

int
send_query_message(char *search_key)
{
    int slen;
    slen = strlen(search_key);

    if(slen > KEY_MAX) {
        p2plog(ERROR, "Search key too long\n");
        return -1;
    }

    struct P2P_h *ph_out;
    char buf[M_LEN];

    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_QUERY);
    memcpy(buf + HLEN, search_key, slen);
    buf[HLEN + slen] = '\0';
    ph_out->length = htons(slen + 1);

    /* Set message id for query-initiator */
    uint32_t msg_id = gen_msgid("query-initiator");
    if (msg_id == 0) {
        p2plog(ERROR, "Query Message ID failed\n");
        return -1;
    }
    ph_out->msg_id = msg_id;

    int msglen = HLEN + slen + 1;
    g_msg_list_add(msg_new(ph_out, msglen, 0));

    struct nb_node *nb;
    list_for_each_entry(nb, &g_nb_list.list, list) {
        send_p2p_message(nb->connfd, ph_out, msglen);
    }

    return 0;
}

int
handle_query_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph_in;
    ph_in = (struct P2P_h *) msg;

    if (g_msg_list_find_by_id(ph_in->msg_id) != NULL) {
        p2plog(DEBUG, "Discard duplicated msg\n");
        return -1;
    }

    g_msg_list_gc();
    g_msg_list_add(msg_new(ph_in, len, connfd));

    /* match local keys */
    uint32_t kval;
    if ((kval = g_kv_list_search(ph_in, len)) != 0) {
        send_query_hit(connfd, ph_in, kval);
    }

    /* still forward msg to find more result */
    ph_in->ttl --;
    flood_msg(connfd, ph_in, len);
    p2plog(DEBUG, "flood query message\n");

    return 0;
}

int
send_query_hit(int connfd, void *msg, uint32_t val)
{
    struct P2P_h *ph_in, *ph_out;
    char buf[S_LEN];
    
    ph_in = (struct P2P_h *) msg;
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_QHIT);
    ph_out->msg_id = ph_in->msg_id;

    /* We don't support fussy matching currently. Therefore, only one entry 
     * for each query. */
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;
    
    qf = (struct P2P_qhit_front *) (buf + HLEN);
    memset(qf, 0, QHIT_MINLEN);
    qf->entry_size = htons(1);

    qe = (struct P2P_qhit_entry *) (buf + HLEN + QHIT_MINLEN);
    memset(qe, 0, QHIT_ENTRYLEN);
    qe->res_id = htons(1);
    qe->res_val = htonl(val);

    send_p2p_message(connfd, ph_out, HLEN + QHIT_MINLEN + QHIT_ENTRYLEN);

    return 0;
}

int
handle_query_hit(void *msg, unsigned int len)
{
    struct P2P_h *ph_in;
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;

    ph_in = (struct P2P_h *) msg;
    qf = (struct P2P_qhit_front *) ((char *)msg + HLEN);

    if (ntohs(ph_in->length) < QHIT_MINLEN) {
        p2plog(ERROR, "QUERY HIT too small\n");
        return -1;
    }

    uint16_t nEntry;
    nEntry = ntohs(qf->entry_size);
    if ((nEntry * QHIT_ENTRYLEN + QHIT_MINLEN + HLEN) != len) {
        p2plog(ERROR, "Invalid entry size for QUERY_HIT: %d\n", nEntry);
        return -1;
    }

    struct message *msg_saved;
    if ((msg_saved = g_msg_list_find_by_id(ph_in->msg_id)) != NULL) {
        if (msg_saved->fromfd == 0) {
            /* This QHIT has reached the QUERY initiator. */
            char buf[S_LEN];
            memcpy(buf, (char *)msg_saved->content + HLEN, 
                   msg_saved->len - HLEN);
            /* Make sure search key is NULL-terminated */
            buf[msg_saved->len - HLEN] = '\0';
            p2plog(INFO, "Query: \"%s\" hit at %s\n", buf, 
                   sock_ntop((struct in_addr*)&ph_in->org_ip, ph_in->org_port));

            int i;
            for (i = 0; i < nEntry; i++) {
                qe = (struct P2P_qhit_entry *)
                     ((char *)msg + HLEN + QHIT_MINLEN + QHIT_ENTRYLEN * i);
                p2plog(INFO, "Resource: 0x%08x = 0x%08X\n", 
                       ntohs(qe->res_id), ntohl(qe->res_val));
            }
        } else {
            /* This QHIT is for a previously forwarded QUERY. */
            struct nb_node *nb;
            if((nb = g_nb_list_find_by_connfd(msg_saved->fromfd)) != NULL){
                ph_in->ttl --;
                /* Relay it back. */
                forward_p2p_message(nb->connfd, msg, len);
            } else {
                p2plog(ERROR, "No matched peer\n");
                return -1;
            }
        }
    } else {
        p2plog(ERROR, "No matched message\n");
        return -1;
    }

    return 0;
}

int
handle_bye_message(int connfd)
{
    struct nb_node *nb;

    if ((nb = g_nb_list_find_by_connfd(connfd)) == NULL) {
        p2plog(ERROR, "BYE cannot match a neighbor fd\n");
        return -1;
    }

    Close(connfd);
    g_pc_list_remove_by_connfd(connfd);
    g_nb_list_del(nb);

    return 0;
}

