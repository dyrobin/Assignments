/**
 * @brief handler functions for messages of our home-brew p2p protocol.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> 
#include <time.h>
#include <ifaddrs.h>
#include <arpa/inet.h>

#include "list.h"
#include "sock_util.h"
#include "util.h"
#include "proto.h"


extern int listen_fd;               /* The listening socket for the P2PN */
extern struct sockaddr_in ltn_addr; /* Current the listening address */

extern struct ifaddrs *if_addrs;

extern struct node_meta neighbors;  /* The list of neighbor nodes */

extern struct msgstore g_recvmsgs;  /* Save messages to prevent loop in 
                                       forwarding */
extern int suppress_auto_join;      /* Whether to join newly discovered 
                                       peers automatically */
extern int n_peer_ad;               /* number of peers presented in the 
                                       peer advertisement */

#define SLEN    128
#define MLEN    256

static int msg_seq = 0;

/*----------------- A hash implementation -------------------------------*/
#undef get16bits
#define get16bits(d) (*((const uint16_t *) (d)))

static uint32_t
SuperFastHash (const char * data, int len) {
    uint32_t hash = len, tmp;
    int rem;

    if (len <= 0 || data == NULL) return 0;

    rem = len & 3;
    len >>= 2;

    /* Main loop */
    for (;len > 0; len--) {
        hash  += get16bits (data);
        tmp    = (get16bits (data+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        data  += 2*sizeof (uint16_t);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
        case 3: hash += get16bits (data);
                hash ^= hash << 16;
                hash ^= data[sizeof (uint16_t)] << 18;
                hash += hash >> 11;
                break;
        case 2: hash += get16bits (data);
                hash ^= hash << 11;
                hash += hash >> 17;
                break;
        case 1: hash += *data;
                hash ^= hash << 10;
                hash += hash >> 1;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}
/*---------------- END of the hash implementation -----------------------*/

/**
 * Initialize the protocol header.
 *
 * @param ph      the p2p protocol header.
 * @param msgType the type of the message.
 */
static void
init_p2ph(struct P2P_h* ph, uint8_t msgType)
{
    memset(ph, 0, sizeof(struct P2P_h));

    ph->version = 1;
    ph->ttl = 5;
    ph->msg_type = msgType;
    ph->length = 0;
    ph->reserved = 0;
}

/**
 * Generate a message ID for new messages.
 *
 * The ID is generated by combining a prefix, current time stamp and the
 * message sequence together, and then hash the combination.
 *
 * @param prefix the prefix for hashing.
 */
static uint32_t
gen_msgid(char *prefix)
{
    char buf[512];
    struct timeval now;
    int n;

    if (msg_seq == 0) { /* initial the sequence number */
        srand(time(NULL));
        msg_seq = rand() % 0xFFFF;
    }

    gettimeofday(&now, NULL);

    n = sprintf(buf, "%s#%ld#%ld#%u",
        prefix, now.tv_sec, now.tv_usec, ++msg_seq);

    return SuperFastHash(buf, n);
}

static uint32_t
is_myself(struct in_addr *addr, uint16_t port)
{
    if (port != ltn_addr.sin_port)
        return 0;

    struct ifaddrs *ifa;
    for (ifa = if_addrs; ifa != NULL; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == NULL)
            continue;

        if (ifa->ifa_addr->sa_family == AF_INET) {
            struct in_addr *tmp;
            tmp = &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
            if (memcmp(addr, tmp, sizeof(struct in_addr)) == 0)
                return 1;
        }
   }

   return 0;
}


static uint32_t
gen_msgid_wrap()
{
    char buf[SLEN];

    sprintf(buf, "%08X:%04X",
            ltn_addr.sin_addr.s_addr,
            ntohs(ltn_addr.sin_port));
    return gen_msgid(buf);
}

static int
send_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;
    char buf[128];
    unsigned int nbody;
    struct sockaddr_in outgoing_addr;
    socklen_t addrlen;

    struct node_meta *nm_tmp; 
    struct wtnode_meta *wtn_tmp; 
    char buf_tmp[SLEN];
    nm_tmp = nm_find_by_connfd(connfd);
    wtn_tmp = wtn_find_by_connfd(connfd);

    if (nm_tmp != NULL && wtn_tmp == NULL) {
        p2plog(DEBUG, "To neighbor %s:%d\n", 
            inet_ntop(AF_INET, &nm_tmp->ip, buf_tmp, SLEN), 
            ntohs(nm_tmp->lport));
    } else if (nm_tmp == NULL && wtn_tmp != NULL) {
        p2plog(DEBUG, "To waiting node %s:%d\n", 
            inet_ntop(AF_INET, &wtn_tmp->ip, buf_tmp, SLEN), 
            ntohs(wtn_tmp->lport));
    } else if (nm_tmp == NULL && wtn_tmp == NULL) {
        p2plog(ERROR, "No destination found in lists");
        return -1;
    } else {
        p2plog(ERROR, "Destination found in both lists");
        return -1;
    }

    ph = (struct P2P_h *) msg;

    /* Filling IP and PORT in header if necessary */
    if (ph->org_ip == 0) {
        /* Set org_ip and port */
        addrlen = sizeof(struct sockaddr_in);
        if (GetSockName(connfd, (struct sockaddr *)&outgoing_addr, 
                        &addrlen) == 0) {
            ph->org_ip = outgoing_addr.sin_addr.s_addr;
        } else {
            if (ltn_addr.sin_addr.s_addr != INADDR_ANY)
                ph->org_ip = ltn_addr.sin_addr.s_addr;
            else {
                p2plog(ERROR, "Orginal IP set failed");
                return -1;
            }
        }
        ph->org_port = ltn_addr.sin_port;
    }

    /* Filling the message id in header if necessary */
    if (ph->msg_id == 0) {
        sprintf(buf, "%08X:%04X",
                ph->org_ip, ntohs(ph->org_port));
        ph->msg_id = gen_msgid(buf);
    }

    /* filling the length field in header */
    nbody = len - HLEN;
    ph->length = htons(nbody);

    /* sendint to the remote destination */
    int nbytes, nsent, nleft;
    nsent = 0;
    nleft = len;
    while (nleft) {
        if ((nbytes = Write(connfd, (char*)msg + nsent, nleft)) < 0) {
        /* TODO: Check errno == EINTR */
            p2plog(ERROR, "Write error, close fd = %d\n", connfd);
            if (nm_tmp) nm_list_del(nm_tmp);
            if (wtn_tmp) wt_list_del(wtn_tmp);
            remove_peer_cache(connfd);
            Close(connfd);
            return -1;
        }
        nsent += nbytes;
        nleft -= nbytes;
    }

    p2plog(DEBUG, "Out MSG: [%08x], msg_type = %02x, len = %d, ttl = %d\n",
            ph->msg_id, ph->msg_type, ntohs(ph->length), ph->ttl);
    return 0;
}



static int
forward_p2p_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;

    ph = (struct P2P_h *) msg;
    if (ph->ttl < 1) {
        p2plog(ERROR, "Forward message with TTL < 1\n");
        return -1;
    }
    send_p2p_message(connfd, msg, len);

    return 0;
}

static int
flood_msg(int fromfd, void *msg, unsigned int len)
{
    struct node_meta *nm;

    list_for_each_entry(nm, &neighbors.list, list) {
        if (nm->connfd != fromfd) {
            forward_p2p_message(nm->connfd, msg, len);
        }
    }
    return 0;
}

/*------------------------------------------------------------------------*/

uint32_t 
send_join_message(int connfd)
{
    struct P2P_h ph;
    init_p2ph(&ph, MSG_JOIN);

    send_p2p_message(connfd, &ph, sizeof(ph));
    return ph.msg_id;
}

int
handle_join_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph_in, *ph_out;
    struct P2P_join *pj;
    struct wtnode_meta *wtn;
    struct node_meta *nm;
    char buf[128];

    ph_in = (struct P2P_h *) msg;
    memset(buf, 0, 128);
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_JOIN);
    ph_out->ttl = 1;
    ph_out->msg_id = ph_in->msg_id;

    p2plog(DEBUG, "Message len = %d, body len = %d\n",
       len, ntohs(ph_in->length));

    if (len == HLEN) { /* JOIN REQUEST */
        /* JOIN message is sent normally after a node connects another one
         * successfully. However, we also allow an established neighbor to 
         * send JOIN in case the response is somehow lost. */
        nm = nm_find_by_connfd(connfd);
        if (nm == NULL) {
            /* The normal case, JOIN message is from incoming list (merged 
             * with waiting list here) */
            wtn = wtn_find_by_connfd(connfd);
            if (wtn == NULL) {
                /* JOIN message is neither from neighbor list nor incoming list
                 * This is not allowed, so we drop this message */
                p2plog(ERROR, "JOIN from an unknown node, connfd = %d\n", 
                       connfd);
                return -1;
            }

            /* Check again if it comes from incoming list */
            if (wtn->nrequest != 0) {
                p2plog(ERROR, "JOIN STATE error, connfd = %d\n", 
                       connfd);
                return -1;
            }

            /* This is a self-loop */
            /*
            if (wtn_find_by_joinid(ph_in->msg_id) != NULL) {
                p2plog(WARN, "JOIN from ourself - loop detected.\n");
                return -1;
            }
            */

            /* Check if waiting list or neighbor list has already contains 
             * it by indentifying its IP address and listening port. */
            if (!wtn_contains(&wtn->ip, ph_in->org_port) && 
                !nm_contains(&wtn->ip, ph_in->org_port)) {
                /* This is a new neighbor, insert it into neighbor list */
                nm = (struct node_meta*) Malloc(sizeof(struct node_meta));
                nm_init(nm);
                nm->connfd = wtn->connfd;
                nm->ip = wtn->ip;
                nm->lport = ph_in->org_port;
                nm_list_add(nm);                
                p2plog(INFO, "NEW NEIGHBOR: Accept a new neighbor, %s\n",
                       sock_ntop(&nm->ip, nm->lport));
                wt_list_del(wtn);
            } else {
                /* The neighborhood of peer has been established or will be 
                 * established later on in handle_waiting_list(). Thus, we
                 * close current connect and remove cache for it. */
                remove_peer_cache(wtn->connfd);
                Close(wtn->connfd);
                wt_list_del(wtn);
                return -1;
            }
        }
        /* common action: send JOIN_ACC */
        pj = (struct P2P_join *) (buf + HLEN);
        pj->status = htons(JOIN_ACC);
        send_p2p_message(connfd, buf, HLEN + JOINLEN);
    } else if (len == HLEN + JOINLEN
                && ntohs(ph_in->length) == JOINLEN) { /* JOIN RESPONSE */
        pj = (struct P2P_join *) ((char *)msg + HLEN);
        p2plog(DEBUG, "join response: 0x%04X\n", ntohs(pj->status));
        if (ntohs(pj->status) != JOIN_ACC) {
            p2plog(ERROR, "JOIN Refused\n");
            return -1;
        }
        /* we are accepted by the remote peer
           therefore we should remove the record in the
           waiting list and put it into our neighbor database. */
        wtn = wtn_find_by_connfd(connfd);
        if (wtn == NULL) {
            p2plog(ERROR, 
                "JOIN request accepted by a non-wtn node, connfd=%d\n", connfd);
            return -1;
        }
        nm = nm_find_by_connfd(connfd);
        if (nm == NULL) {
            nm = (struct node_meta*) Malloc(sizeof(struct node_meta));
            nm_init(nm);
            nm->connfd = wtn->connfd;
            nm->ip = wtn->ip;
            nm->lport = wtn->lport;
            nm_list_add(nm);
            wt_list_del(wtn);
            p2plog(INFO, "NEW NEIGHBOR: JOIN request is accepted by %s\n",
                   sock_ntop(&nm->ip, nm->lport));
        }
    }

    return 0;
}

int
send_ping_message(int connfd, int ttl)
{
    struct P2P_h ph;
    init_p2ph(&ph, MSG_PING);

    ph.ttl = ttl;
    send_p2p_message(connfd, &ph, sizeof(ph));

    return 0;
}

int
handle_ping_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph_in, *ph_out;
    struct P2P_pong_front *pf;
    struct P2P_pong_entry *pe;
    struct node_meta *nm;
    char buf[128];
    int count, pong_len;

    ph_in = (struct P2P_h *)msg;

    memset(buf, 0, 128);
    ph_out = (struct P2P_h *) buf;
    init_p2ph(ph_out, MSG_PONG);
    ph_out->ttl = 1;
    ph_out->msg_id = ph_in->msg_id;

    p2plog(DEBUG, "TTL=%d\n", ph_in->ttl);
    if (ph_in->ttl == 1 && len == HLEN) { /* heartbeat */
        send_p2p_message(connfd, buf, HLEN);
    } else if (ph_in->ttl > 1) { /* network probe */
        count = 0;

        list_for_each_entry(nm, &neighbors.list, list) {
            pe = (struct P2P_pong_entry *)
                    (buf + HLEN + PONG_MINLEN + count * PONG_ENTRYLEN);
            if (nm->connfd != connfd) {
                pe->ip = nm->ip;
                pe->port = nm->lport;
                pe->sbz = 0;
                count++;
            }
            if (count >= n_peer_ad)
                break;
        }
        pf = (struct P2P_pong_front *) (buf + HLEN);
        pf->entry_size = htons(count);
        pf->sbz = 0;

        pong_len = HLEN + PONG_MINLEN + count * PONG_ENTRYLEN;
        send_p2p_message(connfd, buf, pong_len);
    }

    return 0;
}

/* TODO: send_pong_message() */

int
handle_pong_message(void *msg, unsigned int len)
{
    struct P2P_pong_front *pf;
    struct P2P_pong_entry *pe;
    struct wtnode_meta *new_wt;
    int i, entry_size;
    char buf[128];

    if (len == HLEN) {
    /* This is a pong message reacting to heartbeat */
        /* TODO: update neighbour info, eg. timestamp */
        return 0;
    }

    if (len > HLEN && len < HLEN + PONG_MINLEN) {
    /* Check the length of pong message */
        p2plog(ERROR, "message length (%d) less than mininum\n", len);
        return -1;
    }

    pf = (struct P2P_pong_front *) ((char *)msg + HLEN);
    entry_size = ntohs(pf->entry_size);
    if (len != entry_size*PONG_ENTRYLEN + PONG_MINLEN + HLEN) {
    /* check if pong's entry size is valid */
        p2plog(ERROR, "invalid length (%d) with entry size = %d\n", 
               len, entry_size);
        return -1;
    }

    /* iterate each pong entry and add it to waiting list */
    pe = (struct P2P_pong_entry *)((char *)msg + HLEN + PONG_MINLEN);
    p2plog(DEBUG, "PONG with %d entries.\n", entry_size);
    if (suppress_auto_join) {
        p2plog(DEBUG, "Auto join suppressed\n");
        return 0;
    }

    for (i = 0; i < entry_size; i++) {
        p2plog(DEBUG, "HLEN: %d\n"
               "PONG_MINLEN %d\n"
               "PONG_ENTRYLEN * i %d\n",
               HLEN, PONG_MINLEN, PONG_ENTRYLEN * i);
        pe = (struct P2P_pong_entry *)
                ((char *)msg + HLEN + PONG_MINLEN + PONG_ENTRYLEN * i);

        /* If the entry contains a self address, ignore it. */
        if (is_myself(&pe->ip, pe->port)) {
            p2plog(INFO, "Self loop detected: %s", 
                   sock_ntop(&pe->ip, pe->port));
            continue;
        }

        if (!wtn_contains(&pe->ip, pe->port) && 
            !nm_contains(&pe->ip, pe->port)) {
            new_wt = (struct wtnode_meta *)Malloc(sizeof(struct wtnode_meta));
            wtn_init(new_wt);
            new_wt->ip = pe->ip;
            new_wt->lport = pe->port;
            wt_list_add(new_wt);
            p2plog(DEBUG, "ENTRY: %s: %d, inserted\n",
                   inet_ntop(AF_INET, &pe->ip, buf, 128), ntohs(pe->port));
        } else {
            p2plog(DEBUG, "ENTRY: %s: %d, dupplicate entry, discarded\n",
                   inet_ntop(AF_INET, &pe->ip, buf, 128), ntohs(pe->port));
        }
    }

    return 0;
}

int
send_query_message(char *search)
{
    unsigned char buf[MLEN];
    struct P2P_h *ph;
    struct node_meta *nm;
    int slen, msglen;

    if((slen = strlen(search)) > 64) {
        p2plog(ERROR, "Search key too long\n");
        return -1;
    }
    ph = (struct P2P_h *) buf;
    init_p2ph(ph, MSG_QUERY);
    ph->msg_id = gen_msgid_wrap();

    memcpy(buf + HLEN, search, slen);
    buf[HLEN + slen] = '\0';

    ph->length = htons(slen + 1);
    msglen = HLEN + slen + 1;
    push_g_recv_msg(0, ph, msglen);
    list_for_each_entry(nm, &neighbors.list, list) {
        send_p2p_message(nm->connfd, ph, msglen);
    }

    return 0;
}

int
handle_query_message(int connfd, void *msg, unsigned int len)
{
    struct P2P_h *ph;
    ph = (struct P2P_h *) msg;

    if (find_stored_msg(&g_recvmsgs, ph->msg_id) != NULL) {
        p2plog(INFO, "discard dupplicated msg.\n");
        return -1;
    }

    gc_msgstore(&g_recvmsgs);
    push_g_recv_msg(connfd, ph, len);
    /* match local keys */
    uint32_t kval;
    if ((kval = search_localdata(ph, len)) != 0) {
        send_query_hit(connfd, ph, kval);
        p2plog(INFO, "QUERY matches local key, QUERY HIT sent.\n");
    }
    /* still forward msg to find more result */
    ph->ttl --;
    flood_msg(connfd, ph, len);
    p2plog(INFO, "flood query message\n");

    return 0;
}

int
send_query_hit(int connfd, void *msg, uint32_t val)
{
    struct P2P_h *pho, *phme;
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;
    unsigned char buf[MLEN];
    int sendlen;

    pho = (struct P2P_h *) msg;
    phme = (struct P2P_h *) buf;

    init_p2ph(phme, MSG_QHIT);
    phme->msg_id = pho->msg_id;

    qf = (struct P2P_qhit_front *) (buf + HLEN);
    memset(qf, 0, QHIT_MINLEN);
    qf->entry_size = htons(1);

    qe = (struct P2P_qhit_entry *) (buf + HLEN + QHIT_MINLEN);
    memset(qe, 0, QHIT_ENTRYLEN);
    qe->res_id = htons(1);
    qe->res_val = htonl(val);

    sendlen = HLEN + QHIT_MINLEN + QHIT_ENTRYLEN;
    send_p2p_message(connfd, buf, sendlen);

    return 0;
}

int
handle_query_hit(void *msg, unsigned int len)
{
    struct msgstore *ms;
    struct P2P_h *ph;
    struct P2P_qhit_front *qf;
    struct P2P_qhit_entry *qe;
    struct node_meta *nm;
    char buf[MLEN];
    unsigned int bodylen, i;
    uint16_t nEntry;

    ph = (struct P2P_h *) msg;
    bodylen = ntohs(ph->length);

    if (bodylen < QHIT_MINLEN) {
        p2plog(ERROR, "Message body too small\n");
        return -1;
    }
    qf = (struct P2P_qhit_front *) ((char *)msg + HLEN);

    nEntry = ntohs(qf->entry_size);
    if ((nEntry * QHIT_ENTRYLEN + QHIT_MINLEN + HLEN) != len) {
        p2plog(ERROR, "Invalid entry size for QUERY_HIT: %d\n", nEntry);
        return -1;
    }

    if ((ms = find_stored_msg(&g_recvmsgs, ph->msg_id)) != NULL) {
        if (ms->fromfd == 0) {
            /* This QHIT has reached the QUERY initiator. */
            memcpy(buf, (char *)ms->msg + HLEN, ms->len - HLEN);
            buf[ms->len - HLEN] = '\0';
            p2plog(INFO, "query: %s hit, at %s:%d\n", buf,
                   inet_ntop(AF_INET, &ph->org_ip, buf, MLEN), 
                   ntohs(ph->org_port));

            for (i = 0; i < nEntry; i++) {
                qe = (struct P2P_qhit_entry *)
                        ((char *)msg + HLEN + QHIT_MINLEN + QHIT_ENTRYLEN * i);
                p2plog(INFO, "resource ID: %08x = %08X\n", ntohs(qe->res_id), 
                       ntohl(qe->res_val));
            }
        } else {
            /* This QHIT is for a previously forwarded QUERY. */
            if((nm = nm_find_by_connfd(ms->fromfd)) != NULL){
                ph->ttl = 1;
                /* Relay it back. */
                forward_p2p_message(nm->connfd, msg, len);
            } else {
                p2plog(INFO, "no matched peer\n");
                return -1;
            }
        }
    } else {
        p2plog(INFO, "no matched message\n");
        return -1;
    }

    return 0;
}

int
handle_bye_message(int connfd)
{
    struct node_meta *nm;

    if ((nm = nm_find_by_connfd(connfd)) == NULL) {
        p2plog(ERROR, "BYE msg cannot match a neighbor fd\n");
        return -1;
    }

    Close(nm->connfd);
    nm_list_del(nm);

    return 0;
}

