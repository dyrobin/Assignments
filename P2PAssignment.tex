\documentclass[12pt, a4paper]{article}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage[pdftex]{graphicx}
\usepackage{verbatimbox}
\usepackage{placeins}
\pagestyle{empty}
\date{Deadline: 31st\ October \ 2013, 23:59, Helsinki time}
\title{Peer-to-Peer Network}
\author{T-110.5150 - Applications and Services in Internet}
\begin{document}
\maketitle
\section{Description}
In this assignment, you will form a small team (maximum 2 members) to implement a peer-to-peer (P2P) application based on a given protocol. The major functionalities of this application include:
\begin{itemize}
\item Join the internal P2P network for this assignment
\item Publish a key in your node and make it visible to other nodes at the P2P network
\item Look up a specific key in the P2P network
\end{itemize}

In order to test and observe the behaviour of P2P nodes, an internal P2P network is constructed.
This network is Gnutella-alike style (a simplified version), without a central facility.
Each node uses a piece of bootstrap information to join the network.
In order to communicate with other nodes, your application should fulfil the requirements of the protocol.
For the details of the protocol, please refer to the next section.
Grading is based on numbers of features your application provides, the final report and the demo.
Please read the grading section for more information.

\section{Protocol Specification and Behaviours}
The protocol for this assignment is a binary protocol and originated from Gnutella 0.6~\cite{gnutella}.
This protocol is built on top of TCP and contains a 16 bytes fix header.
Similar to other binary network protocols, all value fields conform to network byte order.
In order to differentiate from TCP packets, we use the term message in our protocol.

\subsection{Protocol header}
\begin{verbbox}
0                          16                        32
+------------+------------+------------+------------+
|  Version   |     TTL    | Msg Type   |  Reserved  |
+------------+------------+------------+------------+
|       Sender Port       |       Payload length    |
+------------+------------+------------+------------+
|            Original Sender IP Address             |
+------------+------------+------------+------------+
|                     Message ID                    |
+------------+------------+------------+------------+
\end{verbbox}

\begin{figure}[h!]
  \centering
  \theverbbox
  \caption{Protocol header}
    \label{fig:header}
\end{figure}

Figure \ref{fig:header} illustrates the structure of protocol headers.
The meaning of different fields are as follow:

\textbf{Version}: The version of this protocol, always one.
Any message with other version values MUST be dropped.

\textbf{TTL}: Time To Live.
This field MUST be less than or equal to five.
Each time when a message is forwarded, this field MUST be decreased by one.
If TTL of one message equals to zero, this message MUST be dropped.

\textbf{Msg Type}: The types of message, valid values are:
\begin{itemize}
\item 0x00 Ping
\item 0x01 Pong
\item 0x02 Bye
\item 0x03 Join
\item 0x80 Query
\item 0x81 Query Hit
\end{itemize}

\textbf{Original Sender IP Address}: The IPv4 address of the sender who originally sends this message.
The intermediate nodes MUST NOT change this field when forwarding the message.

\textbf{Sender Port}: The listening port number of the originally sender.
The intermediate nodes MUST NOT change this field when forwarding the message.

\textbf{Message ID}: The message ID SHOULD be globally unique for each message. 
One recommendation to generate the ID is put the IP of the sender, port, time stamp, and a sequence number together, then hash them together to form a message ID.

\textbf{Payload length}: the length of payload in bytes.
The header length is NOT included.

\textbf{Reserved}: Set to zero, unused in this version.

\subsection{Types of message}
\subsubsection{0x03 Join}
There are two sub-types of Join message: Join Request and Join Response.
Join Request has no body (payload equals to zero).
A Join Response has a 2 bytes body, which contains the result of Join Request.

A new node sends a Join Request message to a node that is already in the network for the permission of entering the network.
This is the so-called bootstrap process.
The information about the bootstrap server will given soon so you can start testing your code as soon as possible.
A node who has already joined the network may also send a Join Request to another node, in order to expand its own routing table.
Through connecting with more nodes, the stability is guaranteed.
If the Join Request is accepted by a remote peer, it will return a Join Response message with the same message ID and a 0x0200 status code in the message body.
After that, both nodes should consider each other as a normal peer and keep the TCP connection for message exchange.

In version one of our protocol, there is only one valid status code (0x0200).
All other codes are invalid and how to handle these codes are purely based on implementation.
To refuse a Join Request, a standard way is to close the TCP connection.

\begin{verbbox}
0                          16
+------------+------------+
|      Status code        |
+------------+------------+
\end{verbbox}

\begin{figure}[h!]
  \centering
  \theverbbox
  \label{joinrequest}
  \caption{Join message}
\end{figure}

For instance: the message body of a Join acceptance will be:
\begin{verbbox}
0                          16
+------------+------------+
|    0x02    |    0x00    |
+------------+------------+
\end{verbbox}

\begin{figure}[h!]
  \centering
  \theverbbox
  \label{header}
  \caption{Join response}
\end{figure}

\subsubsection{0x00 Ping}
There are two purposes for a Ping message:
\begin{itemize}
\item Availability testing (heart-beat testing)
\begin{itemize}
\item A Ping message with TTL equals to 1.
\item This message is optional, but recommended to send it every 5 seconds.
\item Peers who receive this Ping message must respond with a Pong message (if this peer supports Pong message).
\item If no Ping or Pong message is received from the remote side for several times, a node can consider there is some problem with this peer.
However, the node SHOULD still keep this connection, in case the peer does not support Ping and Pong message.
\end{itemize}
\item Network probing
\begin{itemize}
\item A Ping message with TTL larger than 1.
\item This function aims to find more peers based on existing nodes.
\item A node (if Pong message is supported) receiving this kind of Ping message SHOULD respond a Pong message which contains maximum five entries of its neighbour peers (not include the one who initiates the Ping message).
A node may have more than five entries available, how to choose five from all the neighbours depends on implementation.
Although a good selection strategy greatly enhances the robustness of the network.
For simplicity, you can choose randomly or just first five.
\end{itemize}
\end{itemize}

A Ping message always contains NO message body.
The only different between Ping type A and B is the TTL field.

\subsubsection{0x01 Pong}
Correspondingly, a Pong message also has two types.
Since a PONG message replies a PING message, the original sender IP, sender port and message ID keep unchanged.
\begin{itemize}
\item A Pong message for responding availability testing.
This Pong message carries NO body information.
\item A Pong message for responding network probing.
This Pong message contains its neighbour peer information in the body.
The body of the message consists of: total number of the entries and one entry record(neighbour IP and listening port) for each neighbour.
\end{itemize}

\begin{verbbox}
0                          16                        32
+------------+------------+------------+------------+
|        Entry size       |           SBZ           |
+------------+------------+------------+------------+
|               IP Address of the 1st Entry         |
+------------+------------+------------+------------+
|   Port of 1st Entry     |    	      SBZ           |
+------------+------------+------------+------------+
|               IP Address of the 2nd Entry         |
+------------+------------+------------+------------+
|   Port of 2nd Entry     |    	      SBZ           |
+------------+------------+------------+------------+
|   (the list continues)                            |
+------------+------------+------------+------------+
\end{verbbox}

\begin{figure}[h!]
  \centering
  \theverbbox
  \label{header}
  \caption{Pong message}
\end{figure}

\textbf{Entry size}: the number of entries in the Pong message body.

\textbf{SBZ}: Should be zero. These bits are reserved.

\textbf{IP address of Xnd Entry}: The IP address of Xnd Entry.

\textbf{Port of Xnd Entry}: The listening port number of Xnd Entry.

\subsubsection{0x80 Query}
A Query Message contains a query key in the message body.
It is propagated in the network according to its TTL (forwarded by peers).
A node receiving this message SHOULD look up its own sharing data, and return the matched entries (if any) in a Query Hit message, and it SHOULD also forward this message to its neighbour peers (if TTL is larger than 0) no mater the query is hit or not in its local shared files.

The length of search criteria varies, and the actual length is decided by the Payload length field in the message header.
Nodes MUST NOT change the message ID of a query message while forwarding.
If a node receives a Query Message whose ID is identical to a previous query in a short time period, the node MUST drop this message.

\begin{verbbox}
+------------+------------+------------+------------+
|     Search criteria (variable length)             |
+------------+------------+------------+------------+
\end{verbbox}

\begin{figure}[h!]
  \centering
  \theverbbox
  \label{header}
  \caption{Query message}
\end{figure}


\subsubsection{0x81 Query Hit}
Query Hit message uses the same message ID as the Query message.
It is routed back to the query sender using the reverse path of the Query message.
The body of Query Hit message contains entries of matched resources, each entry provides information: resource ID (unique for the sharing node), resource value.
Like Pong messages, the first 2 bytes of a Query Hit message contains the total number of entries in the message.

\begin{verbbox}
0                          16                        32
+------------+------------+------------+------------+
|        Entry size       |           SBZ           |
+------------+------------+------------+------------+
|    Resource ID (1st)    |           SBZ           |
+------------+------------+------------+------------+
|                Resource Value (1st)               |
+------------+------------+------------+------------+
|    Resource ID (2nd)    |           SBZ           |
+------------+------------+------------+------------+
|                Resource Value (2nd)               |
+------------+------------+------------+------------+
|    (the list continues)                           |
+------------+------------+------------+------------+
\end{verbbox}
\begin{figure}[h!]
  \centering
  \theverbbox
  \label{header}
  \caption{Query Hit}
\end{figure}

\textbf{Entry size}: the number of entries in the Query Hit message body.

\textbf{SBZ}: should be zero.

\textbf{Resource ID (Xnd)}: The ID of the resource.

\textbf{Resource Value}: The value of the resource.

\subsubsection{0x02 Bye}
Bye message is optional with TTL equals to 1.
The receiver MUST NOT forwards this message and MUST close the TCP connection immediately.
The sender SHOULD wait for the termination of the connection and then quit the network.
Bye message takes no message body.

\section{Detailed Instructions and tips}
\subsection*{Which development environment and programming language can I use?}
We highly recommend you to use C under Linux/Unix environment.
If you are not so familiar to network programming, learning it from C enables fully grasp of the network programming concepts.
Conversely, high level languages, normal coming with highly wrap libraries, hide those things from you.

Another alternative language can be considered is Java.
However, we can only provide the protocol specification and some utility functions in C.
If you use Java, you need to implement them by yourself.

\subsection*{Network Byte Order}
The P2P protocol is a binary protocol, and like other network protocol, it follows network byte order.
The network byte order is big-endian.
However, the machine you use for programming is normally x86 architecture.
In other words, it is little-endian.
Remember to consider the endianness \footnote{\url{http://en.wikipedia.org/wiki/Endianness}} when programming (if you programme in C).

\subsection*{How to bootstrap?}
Information regarding the bootstrap network will be announced later through Noppa.
The bootstrap information contains the IP address and the listening port of existing nodes in the network.
A new node can send a Join Message to an IP and port combination to participate in the network.
Also we will provide some test keys so you can search for them inside the network.

\subsection*{Should I implement the full protocol specification in this assignment?}
Implementation of the whole protocol is not mandatory.
Only fulfilling parts of them are enough to accomplish the two tasks.
However, you are encouraged to explore more in your application.

\subsection*{Should I consider NAT or firewall problems?}
In this assignment, we assume that there are no NAT boxes or firewalls between any two nodes, so you do not need to consider them.
In the Gnutella v0.6 protocol, a special PUSH message is adopted to handle these problems.
Read the Gnutella RFC for more information.

\subsection*{Should I provide GUI?}
The purpose of this assignment is not fancy GUI, however if you want to try GUI programming, feel free to do it.

\subsection*{Should I use multi-thread/process?}
The assignment is designed so that it is achievable with a single process.
The programs for different demo task can be separate applications, as long as you achieve the goals.
Though we encourage you to implement a fully functioning node, it is not mandatory.
A related I/O API you might be interested in is \texttt{select()}, which is available in both C and Java.

\subsection*{How to locate the problem in my code?}
For network programming, \emph{Wireshark} or \emph{tcpdump} are really useful to check the contents of the packets you send to the network.
Observe the inbound and outbound packets to check if you really send or receive the messages and wether they satisfy the format of the protocol.

The common debugging tool for Linux is GDB, which allows you to set break points in you application and step through the program.
There is also similar debugger for Java, and can be easily launched in IDE like Eclipse or NetBeans.

Sometimes, printing out the information also helps you to solve the problem.

\subsection*{Think before coding}
Conquer the feature list one by one without having a full view is discouraged.
Eventually you may find that you have to rewrite your application in order to implement the next feature.
Understand all features and have a clear design increase your productivity.
\section{Submission}
Each team will be provided a Niksula Git \footnote{\url{https://git.niksula.hut.fi/}} repository for version control and submission.
Please check also Git documentation \footnote{\url{http://git-scm.com/doc}} if you have not used it before.

You should create an \texttt{assignment\_1} directory in the repository.
The contents of the directory are:
\begin{verbatim}
assignment_1/
  src/
  README
  Report.pdf
\end{verbatim}

\begin{itemize}
\item The \texttt{src} directory contains all your source code.
\item Submit only the source code, NOT binary executables.
\item The \texttt{README} file is a text file and it should explain how to build and run your application.
\item Clearly state your solution for this assignment in \texttt{Report.pdf}. Please be concise and go directly to the main points. The report should be no more than 4 pages long.
\item Please follow the directory structure and naming convention, otherwise your submission will be ignored.
\item If you have other files that need to be included, please explain why you need them in the \texttt{README} file.
\end{itemize}

Deadline is strict and commits of code after the deadline will not be reviewed. Please plan early your workload and test early the features you're implementing. We can't promise 100\% uptime in the bootstrap server so if you can't connect to the bootstrap server please send us an e-mail so we can fix it as soon as possible.

We encourage students to do frequent commits to their assigned repository.
\section{Demo}
The demo time is 30 minutes sharp, which includes 5 minutes for setup, 20 minutes for presenting the application and 5 minutes for questions.
All members should attend the demo session.
The basic requirements are:
\begin{itemize}
\item Show the application is able to search a specified key in the network, and get the value of the specified key.
\item Show the application is able to publish a specified key in the network.
\end{itemize}
You are free to decide how to present other features of your application, but remember to make a plan and finish your demo on time.
Detailed arrangements of demo sessions will be announced later.

\section{Grading}
The assignment is split into several functions, and points are given separately to each function.
To pass the assignment, you have to implement all features in the basic level.
Basic level features also satisfy the basic requirements of demo sessions.

Total: 130 Points

0 - fail ($<$ 20 points).

1 - $\ge$ 20 points.

2 - $\ge$  40 points.

3 - $\ge$ 60 points.

4 - $\ge$ 80 points.

5 - $\ge$  100 points.

Please check the attached tables to see the specific grading we will use.

\begin{table}[htdp]
\caption{Basic (20 points)}
\begin{center}
\begin{tabular}{|p{12cm}|p{2cm}|}
\hline
Send Join Request message in order to join the network & 5 Points \\
\hline
Handle Join Request message. Consider the situation that remote peer closes the connection. & 5 Points\\
\hline
Send Query message with a search key & 5 Points  \\
\hline
Publish a key/value pair in the network and respond to a Query message when its search key equals your published key & 5 Points \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[htdp]
\caption{Advanced (80 points)}
\begin{center}
\begin{tabular}{|p{12cm}|p{2cm}|}
\hline
Respond to Type A Ping message with a Pong.
Tell your neighbour that you are still alive. & 10 points \\
\hline
Send Type A Ping message.
Check if your neighbours are alive. & 10 Points \\
\hline
Respond to Type B Ping message with a Pong.
Tell your neighbour who else you know. & 10 Points \\
\hline
Send Type B Ping message to find more node information in the network & 10 Points \\
\hline
Join multiple peers in order to expand your network & 10 Points \\
\hline
Forward Query message with loop avoidance to help other node to find a resource & 15 Points \\
\hline
Forward Query Hit message by following the reverse path of its corresponding Query message & 15 Points \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[htdp]
\caption{Other (30 points)}
\begin{center}
\begin{tabular}{|p{12cm}|p{2cm}|}
\hline
A clear final Report.
State how you did the assignment.
Comments on the assignment are also welcomed.
No more than 4 pages and do not paste source code. & 10 points \\
\hline
A good demo.
Show good understanding of the assignment, application runs well, and finish the demo on time. & 10 points \\
\hline
Extra points for constructive comments on this assignment, a good implementation, or other unexpected but decent outcome. & 10 points \\

\hline
\end{tabular}
\end{center}
\end{table}


\FloatBarrier

\begin{thebibliography}{1}

\bibitem{gnutella}
Gnutella Protocol v0.6, \url{http://rfc-gnutella.sourceforge.net/src/rfc-0\_6-draft.html}.

\end{thebibliography}


\end{document}
